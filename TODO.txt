* VC
** Reformat - Ctrl+Shift+I

* finish dynamic bindings
** debug registers in test
*** add EnterMethod.RegisterCount
** add nested check
** require &-prefix when rebinding dynamic variables
** add bindings to readme

* reactivate all tests in TODO

* implement explicit references
** use UserLib as base of method body env
** add support for &-args
*** import name while processing method args
** update tests/readme

* add trace macro
** add vm.Trace bool
** add Trace op
** trace body if args

* add Reader.Composite type
** move logic from VM

* add Pair type/reader

* add string calling
** like array
** slice if index is pair

* add if macro

* add for loop
** add array iterator
** add char iterator
** add step iterator

* add ^-macro

* add vararg support
** mark method as vararg if last arg is array form
** (^join [separator [parts]])
** expand iterator on stack before call

* add apply

* add support for \r\n\t in string literals
** add support to String Dump

(let [m {"foo":1 "bar":2 "baz":3}]
  (inc (m "bar"))
  m)

* histogram.sl

(let [input (io/slurp (io/open (ARGS 0))) 
      words (string/split input "\r\n\t .,?!")
      result {}]
  (for w words
    (inc (result (string/down w))))

  (let [wcs (apply Array result)
        swcs (sort wcs (^[l r] (> (rest l) (rest r))))
        i 0]
  (for wc swcs
    (say (second wc) " " (first wc))

    (if (> 10 (inc i)
      (stop))))))

* add IO lib
** open
** slurp
** slurp-lines
** add IStream type

* add Form.CollectIds()

* add maps/sets
** add map reader

* editor
** two panes
*** switch with tab
*** display path
** highlight current line in active pane
** add Editor lib
*** add Pane type
*** x, path?, buffer

(define pane-width (/ (term/width) 2))
(define left-pane (editor/Pane 1 pane-width))
(define right-pane (editor/Pane pane-width pane-width))
(define active-pane left-pane)

(^ switch-pane []
  (set active-pane (if (= active-pane left-pane) right-pane left-pane)))

* add dec macro
** how do you dec a map entry?

* add tail calls

(^ repl []
  (print "sharpl v" VERSION " - may the src be with you\n\n")

  (^ read-input [buffer]
    (print "  ")
    (let [line (read-line)]
      (if line
        (rec (push buffer line)
        (string/join buffer \n)))))
  
  (let [input (read-input [])]
    (if input
      (do 
        (eval input)
        (repl)))))

fib

(^ fib-rec [n]
  (if (< n 2) n (+ (fib-rec (decr n)) (fib-rec (decr n)))))


---

(check T
  (= 42 42))

(check 3
  (+ 1 2))
  
(check 2
  (- 3 1))

(check (- 2)
  (- 1 3))

(check 42
  (* 7 6))

(check 7
  (/ 42 6))

(check 2
  (let [x [1 2 3]]
    (x 1)))
    
(check [1 4 3]
  (let [x [1 2 3]]
    (x 1 4)
    x))

(check "FOO"
  (string/up "Foo"))

(check "foo"
  (string/down "Foo"))



(load "test-lib.sl")

(lib test
  (check test
    (lib))
    
  (define bar (+ foo 7)))

(check 42
  test/bar)

(check user
  (lib))
